<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Sherlock Bia ‚Äî v1.4 (Revela√ß√£o de Pistas e Invent√°rio Modal)</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;800&display=swap" rel="stylesheet">
<style>
/* CSS Variables for theming */
:root {
  --bg: #0b1020;
  --panel: #0f1730;
  --ink: #e6edf7;
  --muted: #9fb2d3;
  --accent: #7dd3fc;
  --accent2: #a7f3d0;
  --warn: #fde68a;
  --danger: #fecaca;
  --ok: #bbf7d0;
  --card: #0c1532;
  --line: #21335c;
  --good: #10b981;
  --bad: #ef4444;
  --gold: #fbbf24;
  --text-base: 16px;
  --text-lg: 18px;
  --shadow-light: 0 4px 8px rgba(0, 0, 0, 0.2);
  --shadow-medium: 0 6px 12px rgba(0, 0, 0, 0.3);
}

/* Base styles */
* {
  box-sizing: border-box;
}

html, body {
  margin: 0;
  height: 100%;
}

body {
  background: radial-gradient(1200px 600px at 20% -10%, #142145 0%, #0b1020 40%) fixed, var(--bg);
  color: var(--ink);
  font-family: 'Inter', system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
  font-size: var(--text-base);
  line-height: 1.6;
}

/* Header */
header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 14px 16px;
  border-bottom: 1px solid var(--line);
  background: #0b1226;
  position: sticky;
  top: 0;
  z-index: 5;
  box-shadow: var(--shadow-medium);
}

header h1 {
  font-size: 1.2rem; /* Adjusted for better responsiveness */
  margin: 0;
  white-space: nowrap; /* Prevent wrapping on smaller screens */
}

.nav {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
}

/* Buttons */
.btn {
  background: var(--panel);
  border: 1px solid var(--line);
  color: var(--ink);
  padding: 8px 12px;
  border-radius: 10px;
  cursor: pointer;
  transition: all 0.2s ease-in-out;
  font-size: 0.95rem;
  text-decoration: none; /* For button-like links */
  display: inline-flex; /* Ensure consistent alignment with icons */
  align-items: center;
  justify-content: center;
}

.btn:hover {
  filter: brightness(1.15);
  transform: translateY(-1px);
  box-shadow: var(--shadow-light);
}

.btn:active {
  transform: translateY(0);
  box-shadow: none;
}

.btn.pri {
  background: linear-gradient(135deg, var(--accent), var(--accent2));
  color: var(--bg); /* Darker text for bright background */
  border: none;
  font-weight: 700;
  box-shadow: 0 4px 10px rgba(125, 211, 252, 0.3); /* Accentuated shadow */
}

.btn.pri:hover {
  filter: brightness(1.05);
  box-shadow: 0 6px 15px rgba(125, 211, 252, 0.4);
}

.btn.ghost {
  background: transparent;
  border: 1px dashed var(--line);
  color: var(--muted);
}

.btn.ghost:hover {
  background: rgba(var(--line), 0.2);
  filter: none;
}

/* Main container */
.container {
  max-width: 1100px;
  margin: 12px auto;
  padding: 12px;
}

/* Grid layout */
.grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(260px, 1fr));
  gap: 16px;
}

/* Card styles */
.card {
  background: linear-gradient(180deg, var(--card), #0a1228 70%, #090f22);
  border: 1px solid var(--line);
  border-radius: 16px;
  padding: 14px;
  box-shadow: var(--shadow-light);
  transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
}

.card:hover {
  transform: translateY(-2px);
  box-shadow: var(--shadow-medium);
}

.card h3 {
  margin: .2rem 0 .4rem 0;
  color: var(--accent); /* Highlight headings */
}

/* Badges and small text */
.badge {
  display: inline-block;
  padding: 4px 8px;
  border: 1px solid var(--line);
  border-radius: 999px;
  font-size: 0.75rem; /* 12px */
  color: #9cc3ff;
  margin-right: 4px;
  background: rgba(var(--line), 0.3);
}

.small {
  font-size: 0.8rem; /* 12px */
  color: var(--muted);
}

.row {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
  align-items: center;
}

/* Stats display */
.stats {
  display: flex;
  gap: 12px;
  align-items: center;
  flex-wrap: wrap;
}

.stat {
  background: #0b142e;
  border: 1px solid var(--line);
  border-radius: 12px;
  padding: 6px 10px;
  font-size: 0.75rem; /* 12px */
  color: #cfe0ff;
}

/* Progress bar */
progress {
  width: 100%;
  height: 10px;
  -webkit-appearance: none;
  appearance: none;
  border-radius: 99px;
  overflow: hidden; /* Ensure border-radius applies */
}

progress::-webkit-progress-bar {
  background: #0b142e;
  border-radius: 99px;
}

progress::-webkit-progress-value {
  background: linear-gradient(90deg, var(--accent), var(--accent2));
  border-radius: 99px;
}

hr {
  border: 0;
  border-top: 1px solid var(--line);
  margin: 12px 0;
}

footer {
  color: var(--muted);
  font-size: 0.75rem; /* 12px */
  text-align: center;
  margin: 16px 0;
}

/* Scene - Melhorado para suportar imagens cartoon */
.scene {
  position: relative;
  height: 360px;
  border-radius: 14px;
  overflow: hidden;
  border: 1px solid var(--line);
  background: #0a1230;
  box-shadow: var(--shadow-medium);
}

.scene-background {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  object-fit: cover;
  z-index: 1;
}

.scene svg {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  z-index: 2;
  background: transparent;
}

.hotspot {
  position: absolute;
  border: 2px dashed #93c5fd;
  border-radius: 10px;
  padding: 6px;
  cursor: pointer;
  background: rgba(11, 20, 46, 0.8);
  color: #dbeafe;
  display: flex;
  align-items: center;
  justify-content: center;
  text-align: center;
  transition: all 0.2s ease-in-out;
  font-size: 0.8rem;
  z-index: 3;
  backdrop-filter: blur(2px);
}

.hotspot:hover {
  background: rgba(11, 20, 46, 0.9);
  transform: scale(1.03);
  box-shadow: 0 0 15px rgba(147, 197, 253, 0.5);
}

/* Toasts */
#toast-container {
  position: fixed;
  right: 12px;
  bottom: 12px;
  z-index: 1000;
  display: flex;
  flex-direction: column-reverse;
  gap: 8px;
  max-width: 90%;
}

.toast {
  background: var(--panel);
  border: 1px solid var(--line);
  padding: 10px 14px;
  border-radius: 10px;
  color: var(--ink);
  box-shadow: var(--shadow-light);
  opacity: 0;
  transform: translateY(20px);
  transition: opacity 0.3s ease-out, transform 0.3s ease-out;
  display: flex;
  align-items: center;
  gap: 8px;
}

.toast.show {
  opacity: 1;
  transform: translateY(0);
}

/* Shop + Achievements */
.shop {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
  gap: 10px;
}

.shop .item {
  border: 1px solid var(--line);
  border-radius: 12px;
  padding: 10px;
  background: #0b1328;
}

.medal {
  display: inline-block;
  padding: 4px 8px;
  border-radius: 999px;
  background: #142554;
  border: 1px solid #27407a;
  color: #bcd7ff;
  font-size: 0.75rem;
  margin: 2px;
  white-space: nowrap;
}

/* Table */
.table {
  width: 100%;
  border-collapse: collapse;
  margin-top: 8px;
  font-size: 0.9rem;
}

.table th, .table td {
  border: 1px solid var(--line);
  padding: 8px;
  text-align: left;
}

.table th {
  background: #0b142e;
  color: #9cc3ff;
}

.switch {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  cursor: pointer;
}

input[type="checkbox"] {
  transform: scale(1.2);
  accent-color: var(--accent2);
}

.large-font {
  font-size: var(--text-lg);
}

.pbar {
  height: 12px;
  background: #0b142e;
  border-radius: 999px;
  border: 1px solid var(--line);
  overflow: hidden;
}

.pfill {
  height: 100%;
  background: linear-gradient(90deg, var(--accent), var(--accent2));
  width: 0%;
}

kbd {
  background: #0b142e;
  border: 1px solid var(--line);
  border-radius: 6px;
  padding: 2px 6px;
  font-family: monospace;
}

/* Welcome */
.welcome {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 60vh;
  text-align: center;
  padding: 20px;
}

.logo {
  font-size: 3rem;
  font-weight: 800;
  letter-spacing: 0.5px;
  background: linear-gradient(90deg, var(--accent), var(--accent2));
  -webkit-background-clip: text;
  background-clip: text;
  color: transparent;
  margin-bottom: 10px;
}

/* Custom Modal for Confirmation, Prompt, and Dialogue */
.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.6);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 100;
  opacity: 0;
  visibility: hidden;
  transition: opacity 0.3s ease-out, visibility 0.3s ease-out;
}

.modal-overlay.show {
  opacity: 1;
  visibility: visible;
}

.modal-content {
  background: var(--card);
  border: 1px solid var(--line);
  border-radius: 16px;
  padding: 25px;
  box-shadow: var(--shadow-medium);
  text-align: center;
  max-width: 450px; /* Increased max-width */
  width: 90%;
  transform: translateY(-20px);
  transition: transform 0.3s ease-out;
  display: flex;
  flex-direction: column;
  gap: 15px;
}

.modal-overlay.show .modal-content {
  transform: translateY(0);
}

.modal-content h3 {
  margin-top: 0;
  color: var(--warn);
}

.modal-content p {
  margin-bottom: 0; /* Remove default margin */
  font-size: 1.1rem;
}

.modal-input {
  width: 100%;
  padding: 10px;
  border: 1px solid var(--line);
  border-radius: 8px;
  background-color: var(--panel);
  color: var(--ink);
  font-size: 1rem;
}

.modal-actions {
  display: flex;
  justify-content: center;
  gap: 10px;
  flex-wrap: wrap; /* Allow buttons to wrap */
}

@media (max-width: 600px) {
  header {
    flex-direction: column;
    gap: 10px;
    padding: 10px;
  }
  header h1 {
    font-size: 1.1rem;
  }
  .nav {
    justify-content: center;
  }
  .btn {
    padding: 6px 10px;
    font-size: 0.85rem;
  }
  .grid {
    grid-template-columns: 1fr;
  }
  .hotspot {
    font-size: 0.7rem;
    padding: 4px;
  }
  .scene {
    height: 250px;
  }
  .modal-content {
    padding: 15px;
  }
  .modal-content p {
    font-size: 1rem;
  }
}
</style>
</head>
<body>
<header>
  <h1>üïµÔ∏è‚Äç‚ôÄÔ∏è Sherlock Bia ‚Äî v1.4</h1>
  <div class="nav">
    <button class="btn" data-action="go-welcome">In√≠cio</button>
    <button class="btn" data-action="go-hub">Mapa de Casos</button>
    <button class="btn" data-action="go-parents">Painel dos Pais</button>
    <button class="btn ghost" data-action="reset-progress">Zerar Progresso</button>
  </div>
</header>
<main class="container" id="app"><!-- conte√∫do renderizado via JS --></main>
<div id="toast-container" aria-live="polite"></div>

<!-- Custom Modals -->
<div id="custom-modal" class="modal-overlay">
  <div class="modal-content">
    <h3 id="modal-title"></h3>
    <p id="modal-message"></p>
    <input type="text" id="modal-input" class="modal-input" style="display: none;">
    <div id="modal-options" class="modal-actions"></div>
  </div>
</div>

<footer>Prot√≥tipo com cen√°rios cartoon realistas. Imagens geradas dinamicamente para cada ambiente.</footer>

<script>
// =====================================
// Module: Global State & Storage
// =====================================
const Storage = (function() {
  const KEY = 'sbia_state_v1_4'; // Updated key for new version
  const defaultState = () => ({
    user: { name: 'Bia', level: 1, points: 0, coins: 0, medals: [], settings: { largeFont: false, narration: false } },
    sessions: {},
    week: new Date().toISOString().slice(0, 10)
  });

  function load() {
    try {
      const stored = localStorage.getItem(KEY);
      return stored ? JSON.parse(stored) : defaultState();
    } catch (e) {
      console.error('Failed to load state from localStorage:', e);
      return defaultState();
    }
  }

  function save(state) {
    try {
      localStorage.setItem(KEY, JSON.stringify(state));
    } catch (e) {
      console.error('Failed to save state to localStorage:', e);
    }
  }

  return { load, save, defaultState };
})();

// =====================================
// Module: Utility Functions
// =====================================
const Utils = (function() {
  function fmtTime(s) {
    const m = Math.floor(s / 60);
    const r = s % 60;
    return `${m}:${String(r).padStart(2, '0')}`;
  }

  function getCase(id) {
    return Data.CASES.find(c => c.id === id);
  }

  // Custom toast notification
  function addToast(txt, type = 'info') {
    const container = document.getElementById('toast-container');
    if (!container) return;

    const t = document.createElement('div');
    t.className = `toast ${type}`;
    t.innerHTML = `<span>${txt}</span>`;
    container.appendChild(t);

    t.offsetHeight;
    t.classList.add('show');

    setTimeout(() => {
      t.classList.remove('show');
      t.addEventListener('transitionend', () => t.remove());
    }, 2200);
  }

  // Generic Custom Modal
  function showCustomModal(title, message, optionsHtml, inputType = 'none') {
    return new Promise((resolve) => {
      const modal = document.getElementById('custom-modal');
      const modalTitle = document.getElementById('modal-title');
      const modalMessage = document.getElementById('modal-message');
      const modalInput = document.getElementById('modal-input');
      const modalOptions = document.getElementById('modal-options');

      modalTitle.textContent = title;
      modalMessage.innerHTML = message; // Changed to innerHTML to allow HTML content
      modalOptions.innerHTML = optionsHtml;

      if (inputType === 'text') {
        modalInput.style.display = 'block';
        modalInput.value = ''; // Clear previous input
        modalInput.focus();
      } else {
        modalInput.style.display = 'none';
      }

      modal.classList.add('show');

      // Add event listeners for the options (buttons or input submit)
      const handleModalClick = (e) => {
        if (e.target.dataset.value) {
          modal.classList.remove('show');
          modalOptions.removeEventListener('click', handleModalClick);
          resolve(e.target.dataset.value);
        } else if (e.target.id === 'modal-confirm-input') {
          modal.classList.remove('show');
          modalOptions.removeEventListener('click', handleModalClick);
          resolve(modalInput.value);
        } else if (e.target.id === 'modal-cancel-input' || e.target.dataset.action === 'cancel-modal') {
          modal.classList.remove('show');
          modalOptions.removeEventListener('click', handleModalClick);
          resolve(null); // Return null on cancel
        }
      };

      modalOptions.addEventListener('click', handleModalClick);
    });
  }

  function showConfirmationModal(message) {
    const options = `<button class="btn pri" data-value="true">Confirmar</button><button class="btn" data-value="false">Cancelar</button>`;
    return showCustomModal('üö® Confirmar A√ß√£o', message, options);
  }

  function showPromptModal(title, message, placeholder = '') {
    const options = `<button class="btn pri" id="modal-confirm-input">Ok</button><button class="btn" id="modal-cancel-input">Cancelar</button>`;
    const originalInputDisplay = document.getElementById('modal-input').style.display; // Store original
    document.getElementById('modal-input').placeholder = placeholder;
    const promise = showCustomModal(title, message, options, 'text');
    // Restore original display after modal closes to not affect other modals
    promise.finally(() => {
        document.getElementById('modal-input').style.display = originalInputDisplay;
    });
    return promise;
  }

  function showOptionsModal(title, message, optionsArray, cancelable = true) {
    let optionsHtml = optionsArray.map((opt, idx) => `<button class="btn" data-value="${opt.value !== undefined ? opt.value : opt.label}">${opt.label}</button>`).join('');
    if (cancelable) {
        optionsHtml += `<button class="btn ghost" data-action="cancel-modal">Cancelar</button>`;
    }
    return showCustomModal(title, message, optionsHtml);
  }


  function showDialogueModal(title, message, options) {
    const optionsHtml = options.map((opt, idx) => `<button class="btn" data-value="${idx}">${opt.label}</button>`).join('');
    return showCustomModal(title, message, optionsHtml + `<button class="btn ghost" data-action="cancel-modal">Sair</button>`);
  }

  function showAccusationModal(caseData) {
    const suspectsHtml = caseData.suspects.map(s => `<button class="btn" data-value="${s.id}">${s.name}</button>`).join('');
    return showCustomModal('‚öñÔ∏è Acusar Suspeito', 'Quem voc√™ acusa?', suspectsHtml + `<button class="btn ghost" data-action="cancel-modal">Cancelar</button>`);
  }


  return { fmtTime, getCase, addToast, showConfirmationModal, showPromptModal, showDialogueModal, showAccusationModal, showOptionsModal, showInventoryModal: null }; // showInventoryModal is now in Utils, initially null, then assigned
})();

// Destructure for easier access
const { fmtTime, getCase, addToast, showConfirmationModal, showPromptModal, showDialogueModal, showAccusationModal, showOptionsModal } = Utils;

// =====================================
// Module: Data Definitions (CASES)
// =====================================
const Data = (function() {
  const CASES = [
    {
      id: 'c-001', title: 'O Rel√≥gio da Escola', chapter: 1, difficulty: 1,
      intro: 'O rel√≥gio da escola sumiu minutos antes do sinal. Quem pegou?',
      suspects: [
        { id: 'zico', name: 'Zico', traits: ['brincalh√£o'] },
        { id: 'lia', name: 'Lia', traits: ['perfeccionista'] },
        { id: 'nara', name: 'Dona Nara', traits: ['zelosa'] }
      ],
      solution: 'zico',
      clues: [
        // k1 now requires revelation through dialogue
        { id: 'k1', text: 'Marca de graxa na porta', weight: 2, hs: { x: 8, y: 50, w: 22, h: 16 }, requiresReveal: true },
        { id: 'k2', text: 'Bilhete rasgado com a letra Z', weight: 1, requires: 'cipher', cipherText: 'Qeb trof√©u foi movido', hs: { x: 64, y: 28, w: 22, h: 16 } },
        { id: 'k3', text: 'Chave velha com etiqueta "Manuten√ß√£o"', weight: 3, requires: 'pattern', patternSeq: [2, 4, 7, 11, 16], patternAnswer: 22, patternHint: '+2,+3,+4,+5...', hs: { x: 40, y: 70, w: 20, h: 16 }, patternOptions: [18, 20, 22, 24] },
        { id: 'z_conf', text: 'Confiss√£o parcial de Zico', weight: 2, isHiddenHotspot: true }
      ],
      dialogues: {
        "zico": {
          start: "z1",
          nodes: {
            "z1": {
              text: "Eu? Pegar o rel√≥gio? S√≥ estava correndo‚Ä¶",
              options: [
                // Option to reveal hotspot k1
                { label: "Perguntar sobre a graxa na porta", next: "z2", effect: { award: "z_conf", revealHotspot: "k1" } },
                { label: "Onde voc√™ estava √†s 10:10?", next: "z3" }
              ]
            },
            "z2": {
              text: "T√°‚Ä¶ fui olhar a sala da manuten√ß√£o. Tentei consertar o rel√≥gio.",
              options: [{ label: "Voc√™ mexeu no rel√≥gio?", next: "z4", effect: { award: "z_conf" } }]
            },
            "z3": { text: "Na Educa√ß√£o F√≠sica! Pergunta pra Lia.", options: [{ label: "Voltar", next: "z1" }] },
            "z4": { text: "Eu s√≥ queria ajudar! N√£o roubei nada.", options: [{ label: "Encerrar", end: true }] }
          }
        },
        "lia": {
          start: "l1",
          nodes: {
            "l1": {
              text: "Eu gosto de tudo certinho. Se o rel√≥gio sumiu, algu√©m bagun√ßou.",
              options: [{ label: "Viu algu√©m no corredor?", next: "l2" }, { label: "Tinha bilhete no quadro?", next: "l3" }]
            },
            "l2": { text: "Vi o Zico saindo da manuten√ß√£o com as m√£os sujas.", options: [{ label: "Encerrar", end: true }] },
            "l3": { text: "Tinha um bilhete rasgado‚Ä¶ com a letra Z.", options: [{ label: "Encerrar", end: true }] }
          }
        }
      },
      description: 'Cena: corredor principal, porta da manuten√ß√£o e quadro de avisos.',
      scene: 'corridor'
    },
    {
      id: 'c-002', title: 'O Mist√©rio do Bolo', chapter: 1, difficulty: 2,
      intro: 'O bolo da diretora foi trocado por um de areia!',
      suspects: [
        { id: 'nino', name: 'Nino', traits: ['arteiro'] },
        { id: 'bia2', name: 'Bia 2', traits: ['curiosa'] },
        { id: 'teo', name: 'Chef T√©o', traits: ['cozinheiro'] }
      ],
      solution: 'nino',
      clues: [
        { id: 'b1', text: 'Migalhas coloridas no ch√£o', weight: 2, hs: { x: 30, y: 74, w: 20, h: 14 } },
        { id: 'b2', text: 'Foto borrada de algu√©m na cozinha', weight: 2, requires: 'cipher', cipherText: 'Cozinha suja de farinha', hs: { x: 62, y: 30, w: 24, h: 16 } },
        { id: 'b3', text: 'Luvas pequenas atr√°s do palco', weight: 3, requires: 'pattern', patternSeq: [1, 2, 4, 8, 16], patternAnswer: 32, patternHint: 'Multiplica√ß√£o por 2', hs: { x: 10, y: 50, w: 22, h: 16 }, patternOptions: [24, 28, 32, 36] }
      ],
      dialogues: {
        "nino": {
          start: "n1", nodes: {
            "n1": {
              text: "Eu? Nunca! Mas areia √© engra√ßada, n√©?",
              options: [{ label: "Isso √© uma confiss√£o?", next: "n2" }, { label: "Onde voc√™ estava?", next: "n3" }]
            },
            "n2": { text: "T√°, eu troquei‚Ä¶ era s√≥ uma brincadeira!", options: [{ label: "Encerrar", end: true }] },
            "n3": { text: "Eu estava na quadra. Pergunta pro T√©o.", options: [{ label: "Voltar", next: "n1" }] }
          }
        },
        "teo": {
          start: "t1", nodes: {
            "t1": { text: "Na minha cozinha? S√≥ com autoriza√ß√£o!", options: [{ label: "Viu algu√©m?", next: "t2" }] },
            "t2": { text: "Um garoto pequeno com luvas‚Ä¶", options: [{ label: "Encerrar", end: true }] }
          }
        }
      },
      description: 'Cena: sal√£o de festas com cozinha ao fundo.',
      scene: 'kitchen'
    },
    {
      id: 'c-003', title: 'O Trof√©u Desaparecido', chapter: 2, difficulty: 3,
      intro: 'O trof√©u da olimp√≠ada escolar sumiu da vitrine.',
      suspects: [
        { id: 'mara', name: 'Mara', traits: ['competitiva'] },
        { id: 'gui', name: 'Gui', traits: ['distra√≠do'] },
        { id: 'jorge', name: 'Jorge', traits: ['zelador'] }
      ],
      solution: 'mara',
      clues: [
        { id: 't1', text: 'Pegada com sola em estrela', weight: 2, hs: { x: 74, y: 70, w: 20, h: 16 } },
        { id: 't2', text: 'Mapa com um X na quadra', weight: 2, requires: 'pattern', patternSeq: [100, 50, 25, 12.5], patternAnswer: 6.25, patternHint: 'Divis√£o por 2', hs: { x: 10, y: 28, w: 22, h: 16 }, patternOptions: [5, 6.25, 7.5, 10] },
        { id: 't3', text: 'Bilhete cifrado "Qeb trof√©u..."', weight: 3, requires: 'cipher', cipherText: 'Wkh wurohx zdv pdqdjhg', hs: { x: 46, y: 38, w: 22, h: 16 } }
      ],
      dialogues: {
        "mara": {
          start: "m1", nodes: {
            "m1": {
              text: "Se eu tivesse o trof√©u, mostraria!",
              options: [{ label: "Sobre a pegada de estrela", next: "m2" }, { label: "Quem tem acesso √† vitrine?", next: "m3" }]
            },
            "m2": { text: "T√™nis novos. Posso ter passado por l√°‚Ä¶", options: [{ label: "Encerrar", end: true }] },
            "m3": { text: "S√≥ o Jorge e a diretora. Eu n√£o.", options: [{ label: "Encerrar", end: true }] }
          }
        }
      },
      description: 'Cena: sagu√£o da escola com vitrine de trof√©us.',
      scene: 'hall'
    }
  ];

  // Scene backgrounds mapping
  const SCENE_BACKGROUNDS = {
    'corridor': './assets/school_hallway_cartoon.png',
    'kitchen': './assets/kitchen_cartoon.png',
    'hall': './assets/hall_cartoon.png',
    'library': './assets/library_cartoon.png' // 'library' added for completeness, but not used in current cases
  };

  function decodeCaesar(s, shift) {
    // This function now correctly *decodes* by shifting characters backwards.
    // It handles both uppercase and lowercase, and special Portuguese characters.
    const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    const portugueseAlphabet = '√Å√Ç√É√Ä√â√ä√ç√ì√î√ï√ö√á';
    const fullAlphabet = alphabet + portugueseAlphabet;
    const fullAlphabetLower = fullAlphabet.toLowerCase();

    return s.split('').map(ch => {
      let charIndex = fullAlphabet.indexOf(ch);
      let isUpperCase = true;

      if (charIndex === -1) {
        charIndex = fullAlphabetLower.indexOf(ch);
        isUpperCase = false;
      }

      if (charIndex !== -1) {
        const currentAlphabet = isUpperCase ? fullAlphabet : fullAlphabetLower;
        // Shift backwards, handling negative results with modulo
        const newIndex = (charIndex - shift + currentAlphabet.length) % currentAlphabet.length;
        return currentAlphabet[newIndex];
      }
      return ch; // Return non-alphabetic characters unchanged
    }).join('');
  }

  return { CASES, SCENE_BACKGROUNDS, decodeCaesar };
})();

// =====================================
// Module: Game State Management
// =====================================
const GameState = (function() {
  let state = Storage.load();

  function getState() { return state; }
  function setState(newState) { state = newState; Storage.save(state); }

  function updateUser(updates) {
    state.user = { ...state.user, ...updates };
    Storage.save(state);
  }

  function getSession(caseId) {
    return state.sessions[caseId] || null;
  }

  function updateSession(caseId, updates) {
    // Ensure `clues` array is always initialized
    if (!state.sessions[caseId]) {
      state.sessions[caseId] = {
        caseId, start: Date.now(), status: 'open',
        clues: [], errors: 0, hints: 0,
        sessionId: `session_${caseId}_${Date.now()}`,
        revealedHotspots: [] // NEW: Initialize revealedHotspots array
      };
    }
    // Deep merge for nested objects like 'result' if necessary, but shallow merge is fine for simple properties.
    state.sessions[caseId] = { ...state.sessions[caseId], ...updates };
    Storage.save(state);
  }

  return { getState, setState, updateUser, getSession, updateSession };
})();

// =====================================
// Module: Scene Rendering with Cartoon Backgrounds
// =====================================
const SceneRenderer = (function() {

  // Enhanced scene builder with cartoon background support
  function buildScene(caseData, session) {
    const sceneType = caseData.scene || 'corridor';
    const backgroundImage = getSceneBackground(sceneType);

    const hotspots = caseData.clues
      .filter(clue => {
        // Only render if it has hotspot coordinates and is not already collected
        if (!clue.hs || session.clues.includes(clue.id)) return false;

        // If it requires revelation, check if its ID is in the session's revealedHotspots list
        if (clue.requiresReveal) {
          return session.revealedHotspots && session.revealedHotspots.includes(clue.id);
        }

        // If it doesn't require revelation (and is not collected), it's always visible
        return true;
      })
      .map(clue => {
        const { x, y, w, h } = clue.hs;
        return `<div class="hotspot" style="left:${x}%; top:${y}%; width:${w}%; height:${h}%;"
                data-action="tap-clue" data-clue-id="${clue.id}" data-session-id="${session.sessionId}" data-case-id="${caseData.id}">üîç</div>`;
      }).join('');

    return `
      <div class="scene">
        <img src="${backgroundImage}" alt="Cen√°rio ${sceneType}" class="scene-background" onerror="this.src='https://placehold.co/1200x400/0b1020/e6edf7?text=Cen√°rio+n√£o+encontrado';" />
        ${buildSceneSVG(sceneType)}
        ${hotspots}
      </div>
    `;
  }

  function getSceneBackground(sceneType) {
    // This now correctly maps to the uploaded image files
    const backgrounds = Data.SCENE_BACKGROUNDS;
    return backgrounds[sceneType] || backgrounds['corridor'];
  }

  // Scene SVG Builder (overlay elements)
  function buildSceneSVG(kind) {
    // Simplified SVG overlays for interactive elements
    // These are subtle visual cues, not the primary background images.
    if (kind === 'corridor') {
      return `
        <svg viewBox="0 0 1200 400" xmlns="http://www.w3.org/2000/svg" style="opacity: 0.3;">
          <!-- Subtle overlay elements for interactivity -->
          <rect x="180" y="80" width="180" height="170" fill="transparent" stroke="#93c5fd" stroke-width="2" stroke-dasharray="5,5" rx="10" opacity="0.5"/>
          <rect x="790" y="50" width="300" height="150" fill="transparent" stroke="#93c5fd" stroke-width="2" stroke-dasharray="5,5" rx="12" opacity="0.5"/>
        </svg>
      `;
    }
    if (kind === 'kitchen') {
      return `
        <svg viewBox="0 0 1200 400" xmlns="http://www.w3.org/2000/svg" style="opacity: 0.3;">
          <rect x="50" y="160" width="150" height="120" fill="transparent" stroke="#93c5fd" stroke-width="2" stroke-dasharray="5,5" rx="8" opacity="0.5"/>
          <ellipse cx="600" cy="210" rx="60" ry="25" fill="transparent" stroke="#93c5fd" stroke-width="2" stroke-dasharray="5,5" opacity="0.5"/>
        </svg>
      `;
    }
    // hall (default)
    return `
      <svg viewBox="0 0 1200 400" xmlns="http://www.w3.org/2000/svg" style="opacity: 0.3;">
        <rect x="80" y="80" width="280" height="200" fill="transparent" stroke="#93c5fd" stroke-width="2" stroke-dasharray="5,5" rx="10" opacity="0.5"/>
        <rect x="450" y="80" width="300" height="210" fill="transparent" stroke="#93c5fd" stroke-width="2" stroke-dasharray="5,5" rx="15" opacity="0.5"/>
      </svg>
    `;
  }

  return { buildScene };
})();

// =====================================
// Module: UI Rendering
// =====================================
const UI = (function() {
  function render(html) {
    document.getElementById('app').innerHTML = html;
  }

  function renderWelcome(state) {
    render(`
      <div class="welcome">
        <div class="logo">üïµÔ∏è‚Äç‚ôÄÔ∏è Sherlock Bia</div>
        <p>Bem-vinda, <strong>${state.user.name}</strong>! Voc√™ est√° no n√≠vel <strong>${state.user.level}</strong>.</p>
        <div class="stats">
          <div class="stat">‚≠ê ${state.user.points} pontos</div>
          <div class="stat">ü™ô ${state.user.coins} moedas</div>
          <div class="stat">üèÜ ${state.user.medals.length} medalhas</div>
        </div>
        <div class="row" style="margin-top:20px">
          <button class="btn pri" data-action="go-hub">üó∫Ô∏è Come√ßar Investiga√ß√£o</button>
          <button class="btn" data-action="go-parents">üë™ Painel dos Pais</button>
        </div>
        <div class="row" style="margin-top:10px">
          <label class="switch" for="fontToggle">
            <input id="fontToggle" type="checkbox" data-action="toggle-font" ${state.user?.settings?.largeFont ? 'checked' : ''}>
            <span class="small">Fonte grande</span>
          </label>
        </div>
      </div>
    `);
  }

  function renderHub(state) {
    const cards = Data.CASES.map(c => {
      const session = GameState.getSession(c.id);
      const status = session?.status || 'locked';
      const stars = session?.result?.stars || 0;
      // Example of how to lock chapters based on previous chapter completion
      // For now, let's keep it simple and just show them all
      const isLocked = false; // To simplify for demo, always unlocked. c.chapter > 1 && !state.user.medals.includes('chapter_1');

      return `
        <div class="card ${isLocked ? 'locked' : ''}">
          <h3>${c.title}</h3>
          <div class="row">
            <span class="badge">Cap. ${c.chapter}</span>
            <span class="badge">Dif. ${c.difficulty}</span>
            ${stars > 0 ? `<span class="badge" style="color:var(--gold)">‚≠ê ${stars}</span>` : ''}
          </div>
          <p class="small">${c.intro}</p>
          <div class="row" style="margin-top:8px">
            ${isLocked ?
              '<button class="btn" disabled>üîí Bloqueado</button>' :
              `<button class="btn pri" data-action="start-case" data-case-id="${c.id}">üîç Investigar</button>`
            }
          </div>
        </div>
      `;
    }).join('');

    render(`
      <div class="grid">
        ${cards}
      </div>
      <div class="row" style="margin-top:16px; justify-content:center">
        <button class="btn" data-action="go-welcome">‚üµ Voltar ao In√≠cio</button>
      </div>
    `);
  }

  function renderCase(caseData, state) {
    // Ensure session exists and is initialized
    let session = GameState.getSession(caseData.id);
    if (!session) {
      // Create a new session with proper initialization, including 'clues' as an empty array.
      GameState.updateSession(caseData.id, {
          caseId: caseData.id,
          start: Date.now(),
          status: 'open',
          clues: [], // Initialize clues as empty array
          errors: 0,
          hints: 0
      });
      session = GameState.getSession(caseData.id); // Retrieve the newly created session
    }

    const currentSession = session; // Use this consistent reference
    const cluesFound = currentSession.clues || [];
    const timeSpent = currentSession.timeSpent || (currentSession.start ? Math.floor((Date.now() - currentSession.start) / 1000) : 0);

    // Calculate essential clues count for the inventory
    const essentialClues = caseData.clues.filter(clue => !clue.isHiddenHotspot);
    const essentialCluesFound = essentialClues.filter(clue => cluesFound.includes(clue.id));

    const suspectsList = caseData.suspects
      .map(suspect => `
        <button class="btn" data-action="talk-suspect" data-suspect-id="${suspect.id}" data-case-id="${caseData.id}">
          üí¨ ${suspect.name}
        </button>
      `).join('');

    render(`
      <div class="card">
        <h3>${caseData.title}</h3>
        <p>${caseData.intro}</p>
        <div class="stats">
          <div class="stat">‚è±Ô∏è <b id="timer">${fmtTime(timeSpent)}</b></div>
          <div class="stat">üîç ${cluesFound.length}/${caseData.clues.length} pistas</div>
          <div class="stat">‚ùå <b id="err">${currentSession.errors || 0}</b> erros</div>
        </div>
      </div>

      ${SceneRenderer.buildScene(caseData, currentSession)}

      <div class="row" style="margin-top:8px">
        ${(caseData.clues || []).filter(k => !k.hs && !k.isHiddenHotspot).map(k => {
            const found = currentSession.clues.includes(k.id);
            return `<button class="btn" data-action="tap-clue" data-session-id="${currentSession.sessionId}" data-clue-id="${k.id}" data-case-id="${caseData.id}">${found ? '‚úîÔ∏è' : 'üîç'} ${k.text}</button>`
        }).join('')}
      </div>

      <hr>

      <div class="grid">
        <button class="card" data-action="open-inventory">
          <h3>üéí Invent√°rio de Pistas (${essentialCluesFound.length}/${essentialClues.length})</h3>
          <p class="small">Clique para ver suas pistas e itens coletados.</p>
        </button>
        <div class="card">
          <h3>üë• Interrogat√≥rios</h3>
          <p class="small">Converse para obter pistas (respostas certas liberam itens).</p>
          <div class="row" style="flex-wrap:wrap; gap:8px">
            ${suspectsList}
          </div>
          <div class="row" style="margin-top:12px">
            <button class="btn pri" data-action="make-accusation" data-case-id="${caseData.id}" data-session-id="${currentSession.sessionId}">‚öñÔ∏è Fazer Acusa√ß√£o</button>
          </div>
        </div>
      </div>

      <div class="row" style="margin-top:16px; justify-content:center">
        <button class="btn" data-action="go-hub">‚üµ Voltar ao Mapa</button>
        <button class="btn ghost" data-action="give-hint" data-session-id="${currentSession.sessionId}">üí° Dica (‚àí1 moeda)</button>
      </div>
    `);
     // Re-start timer for this specific session
    MainApp.startTimer(currentSession.sessionId);
  }

  function renderResult(caseId, res) {
    render(`
      <div class="card">
        <h3>‚úÖ Caso resolvido!</h3>
        <p>Pontua√ß√£o: <b>${res.score}</b> ‚Ä¢ Estrelas: ${'‚≠ê'.repeat(res.stars)}</p>
        <p class="small">Condi√ß√µes: ${res.allFound ? 'Todas as pistas; ' : ''}${res.clean ? 'sem erros/dicas; ' : ''}${res.fast ? 'r√°pido; ' : ''}</p>
        <div class="row">
          <button class="btn pri" data-action="go-hub">Concluir</button>
          <button class="btn" data-action="start-case" data-case-id="${caseId}">Rejogar</button>
        </div>
      </div>
    `);
    MainApp.stopTimer(); // Stop timer on result screen
  }


  function renderParents(state) {
    const rows = Object.values(state.sessions).map(s => {
      const c = getCase(s.caseId) || { title: '(Caso removido)' };
      const t = s.timeSpent || (s.start ? Math.floor((Date.now() - s.start) / 1000) : 0);
      return `<tr><td>${new Date(s.start || Date.now()).toLocaleDateString()}</td><td>${c.title}</td><td>${s.status || 'open'}</td><td>${fmtTime(t)}</td><td>${s.errors || 0}</td><td>${s.hints || 0}</td><td>${s.result ? s.result.stars : '-'}</td></tr>`;
    }).join('') || `<tr><td colspan="7" class="small">Sem dados ainda‚Ä¶</td></tr>`;

    render(`
      <div class="card">
        <h3>üë™ Painel dos Pais</h3>
        <div class="row" style="justify-content:space-between">
          <label class="switch" for="narToggle">
            <input id="narToggle" type="checkbox" data-action="toggle-narration" ${state.user?.settings?.narration ? 'checked' : ''}>
            <span class="small">Leitura em voz alta (mock)</span>
          </label>
          <label class="switch" for="fontToggle2">
            <input id="fontToggle2" type="checkbox" data-action="toggle-font" ${state.user?.settings?.largeFont ? 'checked' : ''}>
            <span class="small">Fonte grande</span>
          </label>
        </div>
        <table class="table" style="margin-top:8px">
          <tr><th>Data</th><th>Caso</th><th>Status</th><th>Tempo</th><th>Erros</th><th>Dicas</th><th>‚≠ê</th></tr>
          ${rows}
        </table>
        <div class="row" style="margin-top:10px"><button class="btn" data-action="go-hub">‚üµ Voltar</button></div>
      </div>
    `);
  }

  return { render, renderWelcome, renderHub, renderCase, renderParents, renderResult };
})();

// =====================================
// Module: Game Logic
// =====================================
const GameLogic = (function() {

  async function handleClueClick(clueId, sessionId, caseId) {
    const caseData = getCase(caseId);
    const clue = caseData.clues.find(c => c.id === clueId);
    const session = GameState.getSession(caseId);

    if (!clue || session.clues.includes(clueId)) {
      addToast('Pista j√° registrada ou inv√°lida.', 'info');
      return;
    }

    let clueResolved = false;
    if (clue.requires === 'cipher') {
      const answer = await showPromptModal('üß© Cifra de C√©sar', `Decifre: ${clue.cipherText}\nDica: Deslocamento de 3 letras para tr√°s.`, 'Digite o texto decifrado...');
      if (answer === null) { // User cancelled
          addToast('Cifra cancelada.', 'info');
          return;
      }
      const expected = decodeCaesar(clue.cipherText, 3).toLowerCase();
      if (answer.trim().toLowerCase() === expected) {
        addToast('‚úÖ Cifra resolvida!');
        clueResolved = true;
      } else {
        addToast('‚ùå Resposta incorreta!', 'error');
        GameState.updateSession(caseId, { errors: (session.errors || 0) + 1 });
      }
    } else if (clue.requires === 'pattern') {
        const optionsToDisplay = clue.patternOptions || generatePatternOptions(clue.patternAnswer);
        const choice = await showOptionsModal('üß© Padr√µes & Sequ√™ncias', `Complete a sequ√™ncia: ${clue.patternSeq.join(', ')}, ??\nDica: ${clue.patternHint}`,
            optionsToDisplay.map(opt => ({ label: String(opt), value: opt }))
        );

        if (choice === null) { // User cancelled
            addToast('Padr√£o cancelada.', 'info');
            return;
        }

        if (parseFloat(choice) === clue.patternAnswer) {
            addToast('‚úÖ Padr√£o resolvido!');
            clueResolved = true;
        } else {
            addToast('‚ùå Resposta incorreta!', 'error');
            GameState.updateSession(caseId, { errors: (session.errors || 0) + 1 });
        }
    } else {
      clueResolved = true; // No minigame required, clue is immediately resolved
    }

    if (clueResolved) {
      session.clues.push(clueId);
      GameState.updateSession(caseId, { clues: session.clues });
      addToast(`üîç Pista encontrada: ${clue.text}`);
    }

    // Re-render the case to update clue status and error count
    UI.renderCase(caseData, GameState.getState());
  }

  // Helper function to generate default pattern options if not provided
  function generatePatternOptions(correctAnswer) {
      const options = new Set();
      options.add(correctAnswer);
      // Add some plausible incorrect options around the correct answer
      options.add(correctAnswer - 2);
      options.add(correctAnswer + 2);
      if (correctAnswer > 0) options.add(correctAnswer / 2);
      options.add(correctAnswer * 2);

      // Convert to array, sort, and take max 4-5 options
      const sortedOptions = Array.from(options).sort((a, b) => a - b);
      // Ensure we don't have too many options, slice if needed
      if (sortedOptions.length > 5) {
          return sortedOptions.slice(0, 5);
      }
      return sortedOptions;
  }

  async function handleSuspectTalk(suspectId, caseId) {
    const caseData = getCase(caseId);
    const dialogue = caseData.dialogues[suspectId];

    if (!dialogue) {
      addToast('Este suspeito n√£o tem nada a dizer.', 'info');
      return;
    }

    let currentNodeId = dialogue.start;
    let keepTalking = true;

    while (keepTalking) {
      const node = dialogue.nodes[currentNodeId];
      if (!node) {
        addToast('Fim do di√°logo.', 'info');
        keepTalking = false;
        break;
      }

      const options = node.options || [];
      // Pass options as an array to showDialogueModal
      const choiceIndex = await showDialogueModal(`üí¨ Interrogando: ${caseData.suspects.find(s=>s.id===suspectId).name}`, node.text, options);

      if (choiceIndex === null || choiceIndex === undefined) { // User cancelled or exited modal
        keepTalking = false;
        addToast('Conversa encerrada.', 'info');
        break;
      }

      const selectedOption = options[parseInt(choiceIndex)];

      if (selectedOption) {
        if (selectedOption.effect?.award) {
          const session = GameState.getSession(caseId);
          if (!session.clues.includes(selectedOption.effect.award)) {
            session.clues.push(selectedOption.effect.award);
            GameState.updateSession(caseId, { clues: session.clues });
            addToast(`üîç Nova pista obtida atrav√©s do di√°logo: "${getCase(caseId).clues.find(c => c.id === selectedOption.effect.award).text}"`);
          } else {
            addToast('Voc√™ j√° tem essa pista.', 'info');
          }
        }
        // NEW: Handle revealHotspot effect
        if (selectedOption.effect?.revealHotspot) {
          const session = GameState.getSession(caseId);
          if (!session.revealedHotspots.includes(selectedOption.effect.revealHotspot)) {
            session.revealedHotspots.push(selectedOption.effect.revealHotspot);
            GameState.updateSession(caseId, { revealedHotspots: session.revealedHotspots });
            addToast(`üîç Novo local de interesse revelado!`);
          }
        }

        if (selectedOption.end) {
          addToast('Di√°logo encerrado.', 'info');
          keepTalking = false;
        } else if (selectedOption.next) {
          currentNodeId = selectedOption.next;
        } else { // No next node defined, effectively ends conversation
          keepTalking = false;
          addToast('Op√ß√£o inv√°lida ou di√°logo encerrado.', 'info');
        }
      } else { // Invalid choice or no options left
        keepTalking = false;
        addToast('Op√ß√£o inv√°lida ou di√°logo encerrado.', 'info');
      }
    }
    UI.renderCase(caseData, GameState.getState()); // Re-render the case after dialogue
  }


  async function handleAccusation(caseId, sessionId) {
    const caseData = getCase(caseId);
    const session = GameState.getSession(caseId);

    const accusedSuspectId = await showAccusationModal(caseData);

    if (accusedSuspectId === null) { // User cancelled
      addToast('Acusa√ß√£o cancelada.', 'info');
      return;
    }

    const isCorrect = accusedSuspectId === caseData.solution;

    // Ensure timeSpent is recorded when accusing
    if (!session.timeSpent && session.start) {
      session.timeSpent = Math.floor((Date.now() - session.start) / 1000);
    }

    if (isCorrect) {
      session.status = 'solved';
      const res = GameLogic.evaluate(session);
      session.result = res;
      GameLogic.grantRewards(GameState.getState(), res);
      GameState.updateSession(caseId, session); // Save updated session state
      addToast('üéâ Caso resolvido!', 'ok');
      UI.renderResult(caseId, res); // Render result screen
    } else {
      GameState.updateSession(caseId, { errors: (session.errors || 0) + 1 });
      addToast('‚ùå Acusa√ß√£o incorreta! Continue investigando.', 'error');
      UI.renderCase(caseData, GameState.getState()); // Re-render case to update error count
    }
  }

  function evaluate(sess) {
    const c = getCase(sess.caseId);
    if (!c) return { score: 0, stars: 0, foundCount: 0, allFound: false, fast: false, clean: false };

    const found = c.clues.filter(k => sess.clues.includes(k.id)); // Corrected to use sess.clues
    const weights = found.reduce((a, k) => a + (k.weight || 0), 0);
    const penalties = Math.min(30, (sess.errors * 3) + (sess.hints * 5));
    const minutes = Math.round((sess.timeSpent || 0) / 60);
    const timeBonus = Math.max(0, 20 - minutes); // Max 20 points, decreases with time

    const score = weights - penalties + timeBonus;
    const allRequiredFound = c.clues.every(k => sess.clues.includes(k.id) || k.falsePositive || k.isHiddenHotspot); // Corrected to use sess.clues
    const fast = minutes <= 5;
    const clean = sess.errors === 0 && sess.hints === 0;

    let stars = 1;
    if (allRequiredFound) stars++;
    if (clean) stars++;
    if (fast) stars = Math.min(3, stars); // Fast can earn max 1 star, up to 3 total

    return { score, stars, foundCount: found.length, allFound: allRequiredFound, fast, clean };
  }

  function grantRewards(state, res) {
    const pts = Math.max(0, res.score); // Ensure points are not negative
    state.user.points += pts;
    state.user.coins += res.stars;

    // Award medals
    if (res.clean && !state.user.medals.includes('Sem Erros/Dicas')) {
      state.user.medals.push('Sem Erros/Dicas');
      addToast('üéñÔ∏è Nova Medalha: Sem Erros/Dicas!', 'ok');
    }
    if (res.allFound && !state.user.medals.includes('Olho de √Åguia')) {
      state.user.medals.push('Olho de √Åguia');
      addToast('üéñÔ∏è Nova Medalha: Olho de √Åguia!', 'ok');
    }
    if (res.fast && !state.user.medals.includes('Rel√¢mpago')) {
      state.user.medals.push('Rel√¢mpago');
      addToast('üéñÔ∏è Nova Medalha: Rel√¢mpago!', 'ok');
    }
  }

  return { handleClueClick, handleSuspectTalk, handleAccusation, evaluate, grantRewards };
})();

// =====================================
// Module: Event Handling
// =====================================
const EventHandler = (function() {
  function init() {
    // Event delegation on the main app container for most dynamic elements
    document.getElementById('app').addEventListener('click', handleClick);
    // Specific listeners for header buttons which are static
    document.querySelector('header').addEventListener('click', handleClick);
  }

  async function handleClick(e) {
    // Correctly get the data-action from the target or its closest parent with data-action
    const action = e.target.dataset.action || e.target.closest('[data-action]')?.dataset.action;
    if (!action) return;

    // Extract data attributes reliably from the element that has the action or its closest parent with data-attributes
    const elementWithData = e.target.dataset.action ? e.target : e.target.closest('[data-action]');

    const sessionId = elementWithData?.dataset.sessionId;
    const caseId = elementWithData?.dataset.caseId;
    const clueId = elementWithData?.dataset.clueId;
    const suspectId = elementWithData?.dataset.suspectId;

    switch (action) {
      case 'go-welcome':
        MainApp.goWelcome();
        break;
      case 'go-hub':
        MainApp.goHub();
        break;
      case 'go-parents':
        MainApp.goParents();
        break;
      case 'start-case':
        MainApp.startCase(caseId);
        break;
      case 'tap-clue':
        if (clueId && sessionId && caseId) {
            GameLogic.handleClueClick(clueId, sessionId, caseId);
        } else {
            console.warn('Missing data for tap-clue:', { clueId, sessionId, caseId });
        }
        break;
      case 'give-hint':
        if (sessionId) {
            MainApp.giveHint(sessionId);
        }
        break;
      case 'talk-suspect':
        if (suspectId && caseId) {
            GameLogic.handleSuspectTalk(suspectId, caseId);
        }
        break;
      case 'make-accusation':
        if (caseId && sessionId) {
            GameLogic.handleAccusation(caseId, sessionId);
        }
        break;
      case 'reset-progress':
        MainApp.resetProgress();
        break;
      case 'toggle-font':
        MainApp.toggleFont();
        break;
      case 'toggle-narration':
        MainApp.toggleNarration();
        break;
      case 'open-inventory': // NEW: Handle inventory button click
        MainApp.openInventory();
        break;
      // These actions are handled by the new custom modal system, so they are kept here
      // for completeness but their logic is now within the modal's promise resolution.
      case 'cancel-modal':
        // Handled by modal's internal promise resolution
        break;
      default:
        // console.warn('Unhandled action:', action, e.target);
        break;
    }
  }

  function handleChange(e) {
    const action = e.target.dataset.action;
    if (!action) return;

    switch (action) {
      case 'toggle-font':
        MainApp.toggleFont();
        break;
      case 'toggle-narration':
        MainApp.toggleNarration();
        break;
    }
  }

  // Listen for change events (e.g., checkboxes)
  document.addEventListener('change', handleChange);

  return { init };
})();

// =====================================
// Module: App Initialization
// =====================================
const MainApp = (function() {
  let S = Storage.load(); // Load initial state
  let currentTimerIntervalId = null; // To hold the interval ID for the timer

  // Function to save state
  function saveState() {
    Storage.save(S);
  }

  // --- Timer Functions ---
  function startTimer(sessionId) {
    if (currentTimerIntervalId) clearInterval(currentTimerIntervalId);

    const session = S.sessions[sessionId];
    if (!session || session.status === 'solved') {
        return; // Don't start timer if session is not active
    }

    currentTimerIntervalId = setInterval(() => {
        if (!S.sessions[sessionId] || S.sessions[sessionId].status === 'solved') {
            clearInterval(currentTimerIntervalId);
            currentTimerIntervalId = null;
            return;
        }
        const elapsed = Math.floor((Date.now() - S.sessions[sessionId].start) / 1000);
        S.sessions[sessionId].timeSpent = elapsed;
        const tEl = document.getElementById('timer');
        if (tEl) tEl.textContent = fmtTime(elapsed);
    }, 1000);
  }

  function stopTimer() {
    if (currentTimerIntervalId) {
      clearInterval(currentTimerIntervalId);
      currentTimerIntervalId = null;
    }
  }

  // Safe rendering wrapper
  function safeRender(renderFn) {
    try {
      renderFn(S); // Pass the current state to render functions
    } catch (err) {
      console.error('Render error:', err);
      addToast('Ocorreu um erro ao carregar a tela. Tentando voltar ao hub.', 'danger');
      try {
        UI.renderHub(S);
      } catch (e2) {
        console.error('Fallback to Hub failed:', e2);
        addToast('Erro grave! Por favor, recarregue a p√°gina.', 'danger');
      }
    }
  }

  // --- Navigation Functions ---
  function goWelcome() {
    safeRender(UI.renderWelcome);
  }

  function goHub() {
    stopTimer();
    saveState(); // Save state when leaving a case
    safeRender(UI.renderHub);
  }

  function goParents() {
    safeRender(UI.renderParents);
  }

  async function resetProgress() {
    const confirmed = await showConfirmationModal('Zerar todo o progresso? Isso n√£o poder√° ser desfeito.');
    if (confirmed === 'true') { // Modals now return string 'true'/'false' or null
      S = Storage.defaultState();
      saveState();
      addToast('Progresso zerado!', 'ok');
      goWelcome();
    } else {
      addToast('A√ß√£o cancelada.', 'info');
    }
  }

  // --- Game Interaction Functions (directly called by EventHandler) ---
  function startCase(caseId) {
    const caseData = getCase(caseId);
    if (!caseData) {
      addToast('Caso n√£o encontrado!', 'danger');
      return;
    }
    // UI.renderCase will handle session creation if needed
    safeRender(() => UI.renderCase(caseData, S));
  }

  function giveHint(sessionId) {
    const session = S.sessions[sessionId];
    if (!session) return;

    if ((S.user.coins || 0) <= 0) {
      addToast('Sem moedas para dica.', 'warn');
      return;
    }
    S.user.coins = (S.user.coins || 0) - 1;
    session.hints = (session.hints || 0) + 1;
    saveState();
    addToast('Dica: observe letras cifradas e padr√µes num√©ricos!', 'info');
    // Re-render case to update coin count and error/hint display if needed
    safeRender(() => UI.renderCase(getCase(session.caseId), S));
  }

  // NEW: Function to open the Inventory Modal
  async function openInventory() {
    const currentCaseSession = Object.values(S.sessions).find(s => s.status === 'open');
    if (!currentCaseSession) {
      addToast('Nenhum caso ativo para abrir o invent√°rio.', 'info');
      return;
    }
    const caseData = getCase(currentCaseSession.caseId);
    // Call the newly defined showInventoryModal in Utils
    await Utils.showInventoryModal(caseData, currentCaseSession);
    // No need to re-render the case, as the modal is self-contained.
  }

  // --- Settings Toggles ---
  function toggleFont() {
    S.user.settings.largeFont = !S.user.settings.largeFont;
    saveState();
    addToast('Prefer√™ncia de fonte salva.', 'info');
    document.body.classList.toggle('large-font', S.user.settings.largeFont);

    // Re-render current page to apply font change consistently
    const currentCaseSession = Object.values(S.sessions).find(s => s.status === 'open');
    if (currentCaseSession) {
        safeRender(() => UI.renderCase(getCase(currentCaseSession.caseId), S));
    } else {
        // Assume we are on hub or parents panel, re-render the last active one
        // This is a simplified routing. For more complex apps, a router is better.
        const currentPath = window.location.hash.slice(1);
        if (currentPath.includes('case')) { // If URL hash indicates a case, try to re-render it
            const activeCase = Object.values(S.sessions).find(s => s.status === 'open');
            if (activeCase) safeRender(() => UI.renderCase(getCase(activeCase.caseId), S));
        } else if (document.getElementById('app').innerHTML.includes('Painel dos Pais')) { // Check if parents panel is active
            safeRender(UI.renderParents);
        } else {
            safeRender(UI.renderHub); // Default to hub
        }
    }
  }

  function toggleNarration() {
    S.user.settings.narration = !S.user.settings.narration;
    saveState();
    addToast('Configura√ß√£o salva. (Fun√ß√£o de narra√ß√£o n√£o implementada neste prot√≥tipo)', 'info');
  }

  // Exposed for UI module (timer) to update state
  function updateSessionTime(sessionId, elapsed) {
    if (S.sessions[sessionId]) {
      S.sessions[sessionId].timeSpent = elapsed;
      // Note: We are not calling saveState() here on every tick for performance.
      // State is saved when leaving a case or when a clue/error occurs.
    }
  }

  // Public API for MainApp
  return {
    goWelcome,
    goHub,
    goParents,
    resetProgress,
    startCase,
    giveHint,
    openInventory, // Expose openInventory
    toggleFont,
    toggleNarration,
    updateSessionTime,
    startTimer, // Expose timer controls
    stopTimer,  // Expose timer controls
    init: function() {
      EventHandler.init(); // Initialize event listeners
      // Initial render based on URL or default
      const params = new URLSearchParams(location.search);
      if (params.get('autoplay') === '1') {
        startCase('c-001');
      } else {
        goWelcome();
      }
    }
  };
})();

// =====================================
// NEW: Utils.showInventoryModal definition
// Needs to be defined after Utils is available, but before it's used
Utils.showInventoryModal = async function(caseData, session) {
    const cluesFound = session.clues || [];
    const cluesListHtml = cluesFound
      .map(clueId => {
        const clue = caseData.clues.find(c => c.id === clueId);
        // Only list clues that exist and are not 'hidden hotspots' (which are usually just markers for dialogue progression)
        if (clue && !clue.isHiddenHotspot) {
          return `<li style="text-align: left; margin-bottom: 5px; display: flex; align-items: center; gap: 8px;">
                    <span style="font-size: 1.2em;">‚úîÔ∏è</span>
                    <span><strong>${clue.text}</strong>${clue.weight ? ` <span class="small" style="white-space: nowrap;">(Peso: ${clue.weight})</span>` : ''}</span>
                  </li>`;
        }
        return '';
      })
      .join('') || '<li style="text-align: center;" class="small">Nenhuma pista encontrada ainda...</li>'; // Centered message

    const essentialClues = caseData.clues.filter(clue => !clue.isHiddenHotspot);
    const essentialCluesFound = essentialClues.filter(clue => cluesFound.includes(clue.id));

    const contentHtml = `
      <div style="text-align: center;">
        <p style="font-size: 1.1rem; margin-bottom: 15px;">Voc√™ encontrou ${essentialCluesFound.length} de ${essentialClues.length} pistas essenciais!</p>
        <ul style="list-style-type: none; padding: 0; max-height: 200px; overflow-y: auto; text-align: center;">
          ${cluesListHtml}
        </ul>
      </div>
    `;

    return showCustomModal(
      'üéí Seu Invent√°rio de Pistas',
      contentHtml, // Message now accepts HTML content
      `<button class="btn pri" data-value="close">Fechar</button>`
    );
};


// =====================================
// Bootstrap: Initialize the application
// =====================================
document.addEventListener('DOMContentLoaded', MainApp.init);
</script>
</body>
</html>
